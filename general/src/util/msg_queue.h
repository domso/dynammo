#ifndef general_util_msg_queue_h
#define general_util_msg_queue_h

#include <iostream>
#include <stdint.h>
#include <vector>
#include <atomic>

namespace util {
    //______________________________________________________________________________________________________
    //
    // simple message-interface for inter-thread-communication
    // usage:
    //
    // with blocking:
    // //global:
    // msg_queue box(1024);
    //
    // //producer-thread:
    // auto writer = box.write<int>();
    // *writer.obj = 1;
    // writer.commit();
    //
    // //consumer-thread:
    // auto reader = box.read<int>();
    // int x = *reader->obj;
    // reader.release();
    //______________________________________________________________________________________________________
    class msg_queue {
    public:
        //______________________________________________________________________________________________________
        //
        // Description:
        // - creates the internal buffer with ('size' + 64) * 2 Bytes
        // - the seconds half of the buffer is hidden and prevents the split of an object at the border
        // - the extra part of 64 Bytes simplifies the position pointers
        // - however the 'official' size is always the passed argument 'size'
        // Parameter:
        // size: size of internal buffer
        //______________________________________________________________________________________________________
        msg_queue(const int size);
        //______________________________________________________________________________________________________
        //
        // general way to read messages
        // should generated by msg_queue::read()
        // this->obj is either a pointer to a valid instance of T or nullptr, which indicates a timeout
        // the data is either released by destroying the object or by calling this->release() manually
        // any modification to this->obj after destruction or this->release() will lead to undefined behaviour
        // wrapper for msg_queue::load() and msg_queue::release()
        //______________________________________________________________________________________________________
        template <typename T>
        class reader {
        public:
            reader(const int start, const int size, msg_queue& box, const T* obj) : m_start(start), m_size(size), m_box(box), obj(obj), m_open(obj != nullptr) {

            }

            ~reader() {
                if (m_open) {
                    release();
                }
            }
            //______________________________________________________________________________________________________
            //
            // Description:
            // - releases the acquired data
            //______________________________________________________________________________________________________
            void release() {
                m_box.release(m_start, m_size);
                m_open = false;
            }

            const T* obj;
        private:
            msg_queue& m_box;
            int m_start;
            int m_size;
            bool m_open;
        };
        //______________________________________________________________________________________________________
        //
        // general way to write messages
        // should generated by msg_queue::write()
        // this->obj is either a pointer to a valid instance of T or nullptr, which indicates a timeout
        // the data is either commited by destroying the object or by calling this->commit() manually
        // any modification to this->obj after destruction or this->release() will lead to undefined behaviour
        // wrapper for msg_queue::store() and msg_queue::commit()
        //______________________________________________________________________________________________________
        template <typename T>
        class writer {
        public:
            writer(const int start, const int size, msg_queue& box, T* obj) : m_start(start), m_size(size), m_box(box), obj(obj), m_open(obj != nullptr) {

            }

            ~writer() {
                if (m_open) {
                    commit();
                }
            }
            //______________________________________________________________________________________________________
            //
            // Description:
            // - commits the written data (may be unwritten)
            //______________________________________________________________________________________________________
            void commit() {
                m_box.commit(m_start, m_size);
                m_open = false;
            }

            T* obj;
        private:
            msg_queue& m_box;
            int m_start;
            int m_size;
            bool m_open;
        };
        //______________________________________________________________________________________________________
        //
        // Description:
        // - creates a pointer to a virtual instance of type T at the position 'index' inside the internal buffer
        // - this function does not check boundaries
        // - the index should always be acquired by load() or store()
        // - the direct use of this function should be avoided
        // Parameter:
        // - index: index of the first byte inside the internal buffer
        // Return:
        // - pointer to an instance of T
        //______________________________________________________________________________________________________
        template <typename T>
        T* operator[](const int index) {
            return (T*)(m_data.data() + index);
        }
        //______________________________________________________________________________________________________
        //
        // Description:
        // - creates a reader-instance for 'n' instances of T
        // - blocks until enough commited data is available
        // Parameter:
        // - n: number of requested instances
        // - numTries: number of tries (see load())
        // Return:
        // - valid reader-instance
        //______________________________________________________________________________________________________
        template <typename T>
        reader<T> read(const int n = 1, int numTries = -1) {
            int size = sizeof(T) * n;
            int index = load(size, numTries);
            T* obj = nullptr;

            if (index != -1) {
                obj = (T*)(m_data.data() + index);
            }

            return reader<T>(index, size, *this, obj);
        }
        //______________________________________________________________________________________________________
        //
        // Description:
        // - creates a writer-instance for 'n' instances of T
        // - blocks until enough free data is available
        // Parameter:
        // - n: number of requested instances
        // - numTries: number of tries (reserve load())
        // Return:
        // - valid writer-instance
        //______________________________________________________________________________________________________
        template <typename T>
        writer<T> write(const int n = 1, int numTries = -1) {
            int size = sizeof(T) * n;
            int index = reserve(size, numTries);
            T* obj = nullptr;

            if (index != -1) {
                obj = (T*)(m_data.data() + index);
            }

            return writer<T>(index, size, *this, obj);
        }
        //______________________________________________________________________________________________________
        //
        // Description:
        // - checks if 'n' instances of T are available (commited)
        // Parameter:
        // - n: number of requested instances
        // Return:
        // - true  | data available
        // - false | data unavailable
        //______________________________________________________________________________________________________
        template <typename T>
        bool isAvailable(const int n = 1) const {
            return available() >= sizeof(T) * n;
        }
        //______________________________________________________________________________________________________
        //
        // Description:
        // - checks if 'n' instances of T are free and can be reserved
        // Parameter:
        // - n: number of requested instances
        // Return:
        // - true  | data can be reserved
        // - false | not enough free storage
        //______________________________________________________________________________________________________
        template <typename T>
        bool isFree(const int n = 1) const {
            return free() >= sizeof(T) * n;
        }
        //______________________________________________________________________________________________________
        //
        // Description:
        // - releases [lastFree, lastFree + sizeFree)
        // - needs to be called after load()
        // - blocks (spin-lock) until all previous loads are released
        // - after 'numTries' tries, the function returns without releasing the data (-1 disables this behaviour)
        // - the direct use of this function should be avoided
        // Parameters:
        // - lastFree: start-index
        // - sizeFree: number of bytes to release
        // - numTries: number of tries
        // Return:
        // - true  | on success
        // - false | on timeout
        //______________________________________________________________________________________________________
        bool release(const int lastFree, const int sizeFree, int numTries = -1);
        //______________________________________________________________________________________________________
        //
        // Description:
        // - loads the next commited sizeLoad-bytes
        // - the data needs to be released with release(result, sizeLoad), where result is the return of the load-call
        // - blocks (spin-lock) until enough data is available (may lead to live-lock)
        // - after 'numTries' tries, the function returns without loading the data (-1 disables this behaviour)
        // - if the buffer is not large enough, load() will result in a dead-lock
        // - the direct use of this function should be avoided
        // Parameter:
        // - sizeLoad: number of bytes to load
        // - numTries: number of tries
        // Return:
        // - index of first acquired byte | on success
        // - -1                           | on timeout
        //______________________________________________________________________________________________________
        int load(const int sizeLoad, int numTries = -1);
        //______________________________________________________________________________________________________
        //
        // Description:
        // - commits [lastCommit, lastCommit + sizeCommit)
        // - needs to be called after store()
        // - blocks (spin-lock!) until all previous stores are commited
        // - after 'numTries' tries, the function returns without commiting the data (-1 disables this behaviour)
        // - the direct use of this function should be avoided
        // Parameters:
        // - lastCommit: start-index
        // - sizeCommit: number of bytes to commit
        // - numTries: number of tries
        // Return:
        // - true  | on success
        // - false | on timeout
        //______________________________________________________________________________________________________
        bool commit(const int lastCommit, const int sizeCommit, int numTries = -1);
        //______________________________________________________________________________________________________
        //
        // Description:
        // - reserves the next free sizeLoad-bytes for writing
        // - the data needs to be commited with commit(result, sizeStorage), where result is the return of the store-call
        // - blocks (spin-lock) until enough data is available (may lead to live-lock)
        // - after 'numTries' tries, the function returns without reserving the data (-1 disables this behaviour)
        // - if the buffer is not large enough, store() will result in a dead-lock
        // - the direct use of this function should be avoided
        // Parameter:
        // - sizeStorage: number of bytes to load
        // - numTries: number of tries
        // Return:
        // - index of first reserved byte | on success
        // - -1                           | on timeout
        //______________________________________________________________________________________________________
        int reserve(const int sizeStorage, int numTries = -1);
        //______________________________________________________________________________________________________
        //
        // Return:
        // - size of the buffer
        //______________________________________________________________________________________________________
        int size() const;
        //______________________________________________________________________________________________________
        //
        // Return:
        // - current usage of the internal buffer
        //______________________________________________________________________________________________________
        int usage() const;
        //______________________________________________________________________________________________________
        //
        // Return:
        // - current number of acquired (unreleased) bytes (see release())
        //______________________________________________________________________________________________________
        int acquired() const;
        //______________________________________________________________________________________________________
        //
        // Return:
        // - current number of available (unloaded) bytes (see load())
        //______________________________________________________________________________________________________
        int available() const;
        //______________________________________________________________________________________________________
        //
        // Return:
        // - current number of uncommited bytes (see commit())
        //______________________________________________________________________________________________________
        int uncommited() const;
        //______________________________________________________________________________________________________
        //
        // Return:
        // - current number of free bytes in the internal buffer (see reserve())
        //______________________________________________________________________________________________________
        int free() const;
        //______________________________________________________________________________________________________
        //
        // Description:
        // - prints debug informations about the current state to std::cout
        //______________________________________________________________________________________________________
        void printDebugInfo();
    private:
        int m_size;
        std::vector<unsigned char> m_data;
        std::atomic<int> m_start;
        std::atomic<int> m_end;
        std::atomic<int> m_commit;
        std::atomic<int> m_acquired;
    };
}

#endif



